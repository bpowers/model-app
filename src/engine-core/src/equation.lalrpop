// Copyright 2020 The Model Authors. All rights reserved.
// Use of this source code is governed by the Apache License,
// Version 2.0, that can be found in the LICENSE file.

use crate::ast::UnaryOp::*;
use crate::ast::BinaryOp::*;
use crate::ast::Expr;
use crate::ast::Expr::*;
use crate::common::{self, canonicalize, EquationError};
use crate::token::Token;

grammar<'input>(input: &'input str);

pub Equation: Expr = {
    Expr,
};

Expr: Expr = {
    "if" <c:Expr> "then" <t:Expr> "else" <f:Expr> => If(Box::new(c), Box::new(t), Box::new(f)),
    LCmp,
};

LCmp: Expr = {
    <l:LCmp> "&&" <r:ACmp> => Op2(And, Box::new(l), Box::new(r)),
    <l:LCmp> "||" <r:ACmp> => Op2(Or, Box::new(l), Box::new(r)),
    ACmp,
};

ACmp: Expr = {
    <l:ACmp> "=" <r:Eq>  => Op2(Eq, Box::new(l), Box::new(r)),
    <l:ACmp> "<>" <r:Eq> => Op2(Neq, Box::new(l), Box::new(r)),
    <l:ACmp> "!=" <r:Eq> => Op2(Neq, Box::new(l), Box::new(r)),
    Eq,
};

Eq: Expr = {
    <l:Eq> "<" <r:Add>  => Op2(Lt, Box::new(l), Box::new(r)),
    <l:Eq> "<=" <r:Add> => Op2(Lte, Box::new(l), Box::new(r)),
    <l:Eq> ">" <r:Add>  => Op2(Gt, Box::new(l), Box::new(r)),
    <l:Eq> ">=" <r:Add> => Op2(Gte, Box::new(l), Box::new(r)),
    Add,
};

Add: Expr = {
    <l:Add> "-" <r:Mul> => Op2(Sub, Box::new(l), Box::new(r)),
    <l:Add> "+" <r:Mul> => Op2(Add, Box::new(l), Box::new(r)),
    Mul,
};

Mul: Expr = {
    <l:Mul> "*" <r:Unary> => Op2(Mul, Box::new(l), Box::new(r)),
    <l:Mul> "/" <r:Unary> => Op2(Div, Box::new(l), Box::new(r)),
    Unary,
};

Unary: Expr = {
    "+" <e:Exp> => Op1(Positive, Box::new(e)),
    "-" <e:Exp> => Op1(Negative, Box::new(e)),
    "!" <e:Exp> => Op1(Not, Box::new(e)),
    Exp,
};

Exp: Expr = {
    <l:Exp> "^" <r:App> => Op2(Exp, Box::new(l), Box::new(r)),
    App,
};

App: Expr = {
    <id:Ident> "(" <args:Exprs> ")" => App(id, args),
    Atom,
};

Atom: Expr = {
    <id:Ident> => Var(id),
    "(" <Expr> ")",
    "Num" => {
        use std::str::FromStr;
        let s = <>;
        Const(s.to_string(), f64::from_str(s).unwrap())
    },
};

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Exprs = Comma<Expr>;

Ident: common::Ident = {
    <id:"Iden"> => canonicalize(id),
};

extern {
    type Location = usize;
    type Error = EquationError;
    enum Token<'input> {
        "if" => Token::If,
        "then" => Token::Then,
        "else" => Token::Else,
        "," => Token::Comma,
        "=" => Token::Eq,
        "!=" => Token::Neq,
        "<>" => Token::Neq,
        "<" => Token::Lt,
        "<=" => Token::Lte,
        ">" => Token::Gt,
        ">=" => Token::Gte,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Mul,
        "/" => Token::Div,
        "!" => Token::Not,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "^" => Token::Exp,
        "&&" => Token::And,
        "||" => Token::Or,

        "Iden" => Token::Ident(<&'input str>),
        "Num" => Token::Num(<&'input str>),
    }
}
