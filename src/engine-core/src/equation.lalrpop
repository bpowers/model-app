use crate::ast::UnaryOp::*;
use crate::ast::BinaryOp::*;
use crate::ast::Expr;
use crate::ast::Expr::*;
use crate::common::{self, VariableError};
use crate::token::Token;

grammar<'input>(input: &'input str);

pub Equation: Box<Expr> = {
    Expr,
};

Expr: Box<Expr> = {
    "if" <c:Expr> "then" <t:Expr> "else" <f:Expr>    => Box::new(If(c, t, f)),
    LCmp,
};

LCmp: Box<Expr> = {
    <l:ACmp> "&&" <r:LCmp> => Box::new(Op2(And, l, r)),
    <l:ACmp> "||" <r:LCmp> => Box::new(Op2(Or, l, r)),
    ACmp,
};

ACmp: Box<Expr> = {
    <l:Eq> "=" <r:ACmp>  => Box::new(Op2(Eq, l, r)),
    <l:Eq> "<>" <r:ACmp>  => Box::new(Op2(Neq, l, r)),
    <l:Eq> "!=" <r:ACmp>  => Box::new(Op2(Neq, l, r)),
};

Eq: Box<Expr> = {
    <l:Add> "<" <r:Eq>  => Box::new(Op2(Lt, l, r)),
    <l:Add> "<=" <r:Eq> => Box::new(Op2(Lte, l, r)),
    <l:Add> ">" <r:Eq>  => Box::new(Op2(Gt, l, r)),
    <l:Add> ">=" <r:Eq> => Box::new(Op2(Gte, l, r)),
    Add,
};

Add: Box<Expr> = {
    <l:Mul> "-" <r:Add> => Box::new(Op2(Sub, l, r)),
    <l:Mul> "+" <r:Add> => Box::new(Op2(Add, l, r)),
    Mul,
};

Mul: Box<Expr> = {
    <l:Mul> "*" <r:Unary> => Box::new(Op2(Mul, l, r)),
    <l:Mul> "/" <r:Unary> => Box::new(Op2(Div, l, r)),
    Unary,
};

Unary: Box<Expr> = {
    "+" <e:Exp> => Box::new(Op1(Positive, e)),
    "-" <e:Exp> => Box::new(Op1(Negative, e)),
    "!" <e:Exp> => Box::new(Op1(Not, e)),
    Exp,
};

Exp: Box<Expr> = {
    <l:Exp> "^" <r:App> => Box::new(Op2(Exp, l, r)),
    App,
};

App: Box<Expr> = {
    <id:Ident> "(" <a:Add> "," <b:Add> ")" => Box::new(App(id, vec!(a, b))), // FIXME
    Atom,
};

Atom: Box<Expr> = {
    <id:Ident>    => Box::new(Var(id)),
    "(" <Exprs> ")",
    Int,
};

Exprs: Box<Expr> = {
    Expr,
};

Int: Box<Expr> = {
    Num => Box::new(Const(<> as f64)),
};

Ident: common::Ident = {
    <id:"Iden"> => String::from(id),
};

Num: i64 = {
    "Num",
};

extern {
    type Location = usize;
    type Error = VariableError;
    enum Token<'input> {
        "if" => Token::If,
        "then" => Token::Then,
        "else" => Token::Else,
        "," => Token::Comma,
        "=" => Token::Eq,
        "!=" => Token::Neq,
        "<>" => Token::Neq,
        "<" => Token::Lt,
        "<=" => Token::Lte,
        ">" => Token::Gt,
        ">=" => Token::Gte,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Mul,
        "/" => Token::Div,
        "!" => Token::Not,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "^" => Token::Exp,
        "&&" => Token::And,
        "||" => Token::Or,

        "Iden" => Token::Ident(<&'input str>),
        "Num" => Token::Num(<i64>),
    }
}
