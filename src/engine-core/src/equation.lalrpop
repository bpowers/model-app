use std::rc::Rc;

use crate::ast::UnaryOp::*;
use crate::ast::BinaryOp::*;
use crate::ast::Expr;
use crate::ast::Expr::*;
use crate::common::{self, canonicalize, EquationError};
use crate::token::Token;

grammar<'input>(input: &'input str);

pub Equation: Rc<Expr> = {
    Expr,
};

Expr: Rc<Expr> = {
    "if" <c:Expr> "then" <t:Expr> "else" <f:Expr> => Rc::new(If(c, t, f)),
    LCmp,
};

LCmp: Rc<Expr> = {
    <l:LCmp> "&&" <r:ACmp> => Rc::new(Op2(And, l, r)),
    <l:LCmp> "||" <r:ACmp> => Rc::new(Op2(Or, l, r)),
    ACmp,
};

ACmp: Rc<Expr> = {
    <l:ACmp> "=" <r:Eq>  => Rc::new(Op2(Eq, l, r)),
    <l:ACmp> "<>" <r:Eq> => Rc::new(Op2(Neq, l, r)),
    <l:ACmp> "!=" <r:Eq> => Rc::new(Op2(Neq, l, r)),
    Eq,
};

Eq: Rc<Expr> = {
    <l:Eq> "<" <r:Add>  => Rc::new(Op2(Lt, l, r)),
    <l:Eq> "<=" <r:Add> => Rc::new(Op2(Lte, l, r)),
    <l:Eq> ">" <r:Add>  => Rc::new(Op2(Gt, l, r)),
    <l:Eq> ">=" <r:Add> => Rc::new(Op2(Gte, l, r)),
    Add,
};

Add: Rc<Expr> = {
    <l:Add> "-" <r:Mul> => Rc::new(Op2(Sub, l, r)),
    <l:Add> "+" <r:Mul> => Rc::new(Op2(Add, l, r)),
    Mul,
};

Mul: Rc<Expr> = {
    <l:Mul> "*" <r:Unary> => Rc::new(Op2(Mul, l, r)),
    <l:Mul> "/" <r:Unary> => Rc::new(Op2(Div, l, r)),
    Unary,
};

Unary: Rc<Expr> = {
    "+" <e:Exp> => Rc::new(Op1(Positive, e)),
    "-" <e:Exp> => Rc::new(Op1(Negative, e)),
    "!" <e:Exp> => Rc::new(Op1(Not, e)),
    Exp,
};

Exp: Rc<Expr> = {
    <l:Exp> "^" <r:App> => Rc::new(Op2(Exp, l, r)),
    App,
};

App: Rc<Expr> = {
    <id:Ident> "(" <args:Exprs> ")" => Rc::new(App(id, args)),
    Atom,
};

Atom: Rc<Expr> = {
    <id:Ident> => Rc::new(Var(id)),
    "(" <Expr> ")",
    "Num" => {
        use std::str::FromStr;
        let s = <>;
        Rc::new(Const(s.to_string(), f64::from_str(s).unwrap()))
    },
};

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Exprs = Comma<Expr>;

Ident: common::Ident = {
    <id:"Iden"> => canonicalize(id),
};

extern {
    type Location = usize;
    type Error = EquationError;
    enum Token<'input> {
        "if" => Token::If,
        "then" => Token::Then,
        "else" => Token::Else,
        "," => Token::Comma,
        "=" => Token::Eq,
        "!=" => Token::Neq,
        "<>" => Token::Neq,
        "<" => Token::Lt,
        "<=" => Token::Lte,
        ">" => Token::Gt,
        ">=" => Token::Gte,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Mul,
        "/" => Token::Div,
        "!" => Token::Not,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "^" => Token::Exp,
        "&&" => Token::And,
        "||" => Token::Or,

        "Iden" => Token::Ident(<&'input str>),
        "Num" => Token::Num(<&'input str>),
    }
}
